<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1438080815864">{:repl-history {:ide [], :local [&quot;r-pentomino&quot; &quot;(quit)&quot; &quot;(map #(do (println (cells-to-string %)) (println)) (generations r-pentomino 12))&quot; &quot;(generations r-pentomino 4)&quot; &quot;(when true (println \&quot;true\&quot;))&quot; &quot;(when true \&quot;cat\&quot;)&quot; &quot;(if true \&quot;cat\&quot; \&quot;dog\&quot;)&quot; &quot;(def l \&quot;* *\&quot;)&quot; &quot;(for [x range (count l)] (when (not (or (= c \\space) (= c \\.))) { :x x :y 1 }))&quot; &quot;(for [x (range (count l)) ] (when (not (or (= c \\space) (= c \\.))) { :x x :y 1 }))&quot; &quot;(for [x (range (count l))\n      c (split l)] (println (str x \&quot;=\&quot;) c))&quot; &quot;(require clojure.string)&quot; &quot;(require ['clojure.string :as 'strings\n         ])&quot; &quot;(for [x (range (count l))\n      c (strings/split l \&quot;\&quot;)] (println (str x \&quot;=\&quot;) c))&quot; &quot;(for [x (range (count l))\n      c (strings/split l #\&quot;\&quot;)] (println (str x \&quot;=\&quot;) c))&quot; &quot;(for [x (range (count l))\n      c (strings/split l #\&quot;\&quot;)] (println (str x \&quot;=\&quot; c) ))&quot; &quot;(for [x (range (count l))\n      c (strings/split l #\&quot;\&quot;)] (str x \&quot;=\&quot; c) ))&quot; &quot;(for [x (range (count l))\n      c (strings/split l #\&quot;\&quot;)] (str x \&quot;=\&quot; c) )&quot; &quot;(+ 2 2)&quot; &quot;(generations r-pentomino 2)&quot; &quot;(defn string-to-cells [in]\n  (set (remove nil? (flatten\n                      (let [lines (strings/split-lines in)]\n                        (for [y (range (count lines))]\n                          (let [l (get lines y)]\n                            (for [x (range (count l))]\n                              (let [c (get l x)]\n                                (if (not (or (= c \\space) (= c \\.)))\n                                  (make-cell x y) ))))))))))&quot; &quot;(defn string-to-cells [in]\n  (set (remove nil? \n                      (let [lines (strings/split-lines in)]\n                        (for [y (range (count lines))]\n                          (let [l (get lines y)]\n                            (for [x (range (count l))]\n                              (let [c (get l x)]\n                                (if (not (or (= c \\space) (= c \\.)))\n                                  (make-cell x y) )))))))))&quot; &quot;(string-to-cells \&quot;***\&quot;)&quot; &quot;(defn string-to-cells [in]\n  (set (remove nil? (apply into (let [lines (strings/split-lines in)]\n                                  (for [y (range (count lines))]\n                                    (let [l (get lines y)]\n                                      (for [x (range (count l))]\n                                        (let [c (get l x)]\n                                          (if (not (or (= c \\space) (= c \\.)))\n                                            (make-cell x y) )))))))\n               )))&quot; &quot;(string-to-cells \&quot;*\\n*\\n*\&quot;)&quot; &quot;(into '(:a :b) '(:e :g))&quot; &quot;(apply into '(:a :b))&quot; &quot;(apply into '(:a :b) '(:c :d))&quot; &quot;(apply )&quot; &quot;(apply +\n       '(:a :b) '(:c :d))&quot; &quot;(apply +\n       '(1 2) '(3  :4\n                 ))&quot; &quot;(apply + 1 2 3)&quot; &quot;(reduce + '(1 2 3) )&quot; &quot;(reduce into '(1 2 3) )&quot; &quot;(reduce into '(:a :b :c) '(:e :f) )&quot; &quot;(defn cells-to-string [cells]\n  (let [dims (get-dimensions cells)]\n    (strings/join \\newline\n                  (for [row (range(dims :y-min) (+ (dims :y-max) 1))]\n                    (apply str (for [col (range(dims :x-min) (+ (dims :x-max) 1))]\n                                 (if (nil? (cells { :x col :y row })) \\. \\*)))))))&quot; &quot;(map #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 4)))\n&quot; &quot;(map #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 4))\n&quot; &quot;(apply #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 4))\n&quot; &quot;(take #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 4))\n&quot; &quot;(keep #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 4))\n&quot; &quot;(keep #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 24\n                  ))\n&quot; &quot;(keep #(do (println (cells-to-string %)) (println))\n     (generations r-pentomino 24))\n&quot; &quot;(generations r-pentomino 24)&quot; &quot;(keep #(do (println (cells-to-string %)) (println))\n      (generations r-pentomino 12)))\n&quot; &quot;(def r-pentomino-forever (iterate next-generation r-pentomino))&quot; &quot;(nth r-pentomino-forever 5)&quot; &quot;(println (cells-to-string (nth r-pentomino-forever 5)))&quot; &quot;(println (cells-to-string (nth r-pentomino-forever 10\n                               )))&quot; &quot;(println (cells-to-string (nth r-pentomino-forever 100)))&quot; &quot;(println (cells-to-string (nth r-pentomino-forever 200\n                               )))&quot; &quot;(println (cells-to-string (nth r-pentomino-forever 120)))&quot; &quot;(println (cells-to-string (nth r-pentomino-forever 98)))&quot; &quot;(print \&quot;a\&quot;)&quot; &quot;(-&gt; (print \&quot;a\&quot;) (print \&quot;b\&quot;) (print \\newline))&quot; &quot;(load-file \&quot;conway/core.clj\&quot;)&quot; &quot;(load-file \&quot;core.clj\&quot;)&quot; &quot;(-main)&quot;], :remote []}}</component>
</project>